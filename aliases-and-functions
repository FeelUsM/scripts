#-*- sh -*-

#здесь находятся алиасы и функции, которые можно запускать из других скриптов, если подключить это файл
#но я так ни разу не делал

#=== bool ===
bool(){ test "$@" && echo true || echo false; }
# pred=$(bool 2 = 2)
# if $pred; then ...
# $pred && echo 1 || echo 2

#=== wget ===
alias wgetsite="wget -r -np -k -p -e robots=off -U mozilla --random-wait"
#-r              recursive
#-np no-parent - не подниматься выше заданной директории
#-k              после завершения загрузки конвертировать ссылки
#-p              Загружать все файлы, которые нужны для отображения страниц HTML
#-e robots=off   не подчиняться (obey) robots.txt
#-U mozilla      прикинуться mozillой
#--random-wait   случайное врмя ожидания - чтобы не банили как бота

#=== cadaver ===
alias yacadav='cadaver https://webdav.yandex.ru'

#=== echo $PATH ===
alias path-n='echo $PATH | sed '\''s/:/\n/g'\'

#=== winlink ===
alias winlink='nircmd shortcut'

#=== stack ===
STACK_SEPARATOR="\$'\n'" #how it works is invisible throw echo, but visible throw 'printf "%s"' (under bash)
push()
{
	usage()
	{
		echo usage: push array_name value >&2
	}
	[ $# != 2 ] && { usage; return 1; }

	#echo "$1=\$$1$STACK_SEPARATOR\"$2\""
	eval "$1=\$$1$STACK_SEPARATOR\"$2\""
}
pop()
{
	usage()
	{
		echo usage: pop array_name >&2
	}
	[ $# != 1 ] && { usage; return 1; }

	eval "echo \${$1##*$STACK_SEPARATOR}"
	eval "$1=\${$1%$STACK_SEPARATOR*}"
}
popto()
{
	usage()
	{
		echo usage: popto array_name var_name >&2
	}
	[ $# != 2 ] && { usage; return 1; }

	eval "$2=\${$1##*$STACK_SEPARATOR}"
	eval "$1=\${$1%$STACK_SEPARATOR*}"
}

#=== tar ===
myuntar()
{
	mkdir ${1%.tgz}
	cd ${1%.tgz}
	tar -xzf ../$1
	local c=0
	for x in * ; do
		c=$(($c+1))
	done
	if [ "$c" = 1 ]; then
		mv * ..
	fi
	cd -
	if [ "$c" = 1 ]; then
		rmdir ${1%.tgz}
	fi
}
mytar()
{
	tar -czf $1 -o $1.tgz
}

TRASH_DIR=~/.trash
#=== rm-to-trash ===
if false;then #[ -n "$(cp --version | grep 8.24)" ]; then
    rm-to-trash(){
	#echo $@
	while [ $# -gt 0 ]; do
	    case "$1" in /*) pat="$1";; *) pat="$PWD/$1";; esac
	    shift
	    local dir="$TRASH_DIR/$(dirname "${pat#/}")"
	    #echo "pat= $pat dir= $dir"
	    mkdir -p "$dir" && #echo mkdir OK &&
	    cp -PrI --preserve=timestamp "$pat" "$dir" && #echo cp OK &&
	    env rm -rf "$pat" #&& echo rm OK
	done
    }
else  # difference in cp -i and cp -I
    rm-to-trash(){
	#echo $@
	while [ $# -gt 0 ]; do
	    case "$1" in /*) pat="$1";; *) pat="$PWD/$1";; esac
	    shift
	    local dir="$TRASH_DIR/$(dirname "${pat#/}")"
	    #echo "pat= $pat dir= $dir"
	    mkdir -p "$dir" && #echo mkdir OK &&
	    cp -Pri --preserve=timestamp "$pat" "$dir" && #echo cp OK &&
	    env rm -rf "$pat" #&& echo rm OK
	done
    }
fi
#----

# создает симлинк $1 указывающий на $2
# если файл или симлинк с таким имененм существует - переименовывает его
linkto() {
	#echo "$2" "$1"
	if [ -f "$1" -o -L "$1" ] && [ -z "$(grep -P "\\Q$2\\E\$" <(ls -l "$1") )" ]; then
		date_var="$(date "+%F-%H-%M-%S")"
		mv "$1" "$1".bak-"$date_var"
		echo "$1" moved to "$1".bak-"$date_var"
	fi
	# после переименования не должно остаться $1
	[ -f "$1" -o -L "$1" ] || ln -s "$2" "$1"
}

# добавляет строку $1 в файл $2, если там ее нет
append_line() {
	[ -z "$(grep -P "\\Q$1\\E" "$2")" ] && echo "$1" >> "$2" || return 0
}

# возвращает столбец;строку , где находится курсор
curpos() {
	# based on a script from http://invisible-island.net/xterm/xterm.faq.html
	exec < /dev/tty
	local oldstty=$(stty -g)
	stty raw -echo min 0
	# on my system, the following line can be replaced by the line below it
	echo -en "\033[6n" > /dev/tty
	# tput u7 > /dev/tty    # when TERM=xterm (and relatives)
	local pos
	read -r -d R pos
	stty $oldstty

	#echo -en "\E[6n"
	#local CURPOS
	#read -sdR CURPOS
	echo ${pos#*[}
}
