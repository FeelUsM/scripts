#-*- sh -*-

#здесь находятся алиасы и функции, которые можно запускать из других скриптов, если подключить это файл
#но я так ни разу не делал

#=== bool ===
bool(){ test "$@" && echo true || echo false; }
# pred=$(bool 2 = 2)
# if $pred; then ...
# $pred && echo 1 || echo 2

#=== wget ===
alias wgetsite="wget -r -np -k -p -e robots=off -U mozilla --random-wait"
#-r              recursive
#-np no-parent - не подниматься выше заданной директории
#-k              после завершения загрузки конвертировать ссылки
#-p              Загружать все файлы, которые нужны для отображения страниц HTML
#-e robots=off   не подчиняться (obey) robots.txt
#-U mozilla      прикинуться mozillой
#--random-wait   случайное врмя ожидания - чтобы не банили как бота

#=== cadaver ===
alias yacadav='cadaver https://webdav.yandex.ru'

#=== echo $PATH ===
alias path-n='echo $PATH | sed '\''s/:/\n/g'\'

#=== winlink ===
alias winlink='nircmd shortcut'

#=== stack ===
STACK_SEPARATOR="\$'\n'" #how it works is invisible throw echo, but visible throw 'printf "%s"' (under bash)
push()
{
	usage()
	{
		echo usage: push array_name value >&2
	}
	[ $# != 2 ] && { usage; return 1; }

	#echo "$1=\$$1$STACK_SEPARATOR\"$2\""
	eval "$1=\$$1$STACK_SEPARATOR\"$2\""
}
pop()
{
	usage()
	{
		echo usage: pop array_name >&2
	}
	[ $# != 1 ] && { usage; return 1; }

	eval "echo \${$1##*$STACK_SEPARATOR}"
	eval "$1=\${$1%$STACK_SEPARATOR*}"
}
popto()
{
	usage()
	{
		echo usage: popto array_name var_name >&2
	}
	[ $# != 2 ] && { usage; return 1; }

	eval "$2=\${$1##*$STACK_SEPARATOR}"
	eval "$1=\${$1%$STACK_SEPARATOR*}"
}

#=== tar ===
myuntar()
{
	mkdir ${1%.tgz}
	cd ${1%.tgz}
	tar -xzf ../$1
	local c=0
	for x in * ; do
		c=$(($c+1))
	done
	if [ "$c" = 1 ]; then
		mv * ..
	fi
	cd -
	if [ "$c" = 1 ]; then
		rmdir ${1%.tgz}
	fi
}
mytar()
{
	tar -czf $1 -o $1.tgz
}

TRASH_DIR=~/.trash
#=== rm-to-trash ===
rm-to-trash(){
if [ $# == 0 -o "x$1" = x--help -o "x$1" = x-h ]; then
	echo "usage:"
	echo "   <rm> [-h|--help]         --- вывести этот usage"
	echo "   <rm> -f|-rf objects...   --- вызов системного rm с соответствующими опциями и объектами"
	echo "   <rm> [-v] objects...     --- перемещение объектов в корзину, -v - verbose"
	return 1
fi

if [ "x$1" = x-f -o "x$1" = x-rf ]; then
	env rm "$@" # todo надо сделать вариант вызова rm без аргументов -f и -rf
else
	if [ "x$1" = x-v ];then
		local verbose=1; 
		shift
	else
		local verbose=0
	fi
	local dt="$( date '+%Y-%m-%d %H-%M-%S')"
	local exitcode=0
	while [ $# -gt 0 ]; do
		case "$1" in /*) local fname="${1%/}";; *) local fname="$PWD/${1%/}";; esac
		shift
		local efname="$dt$(echo "$fname" | sed -E 's/%/%%/g; s/\//%-/g')"
		[ $verbose = 1 ] && echo "$fname --> $TRASH_DIR/$efname"
		mv -i "$fname" "$TRASH_DIR/$efname" || exitcode=1
	done
	return $exitcode
fi
}

function restore(){
if [ $# == 0 -o "x$1" = x--help -o "x$1" = x-h ]; then
	echo "usage:"
	echo "   restore [-h|--help]           --- вывести этот usage"
	echo "   restore [-v] [-p] objects...  --- перемещение объектов из корзины на свои места"
	echo "-v - verbose; -p - предварительно создваать папки (если отсутствуют), куда должны быть перемещены объекты"
	echo "объектами могут быть как имена удаленных файлов и каталогов в файловой системе, так и в папке $TRASH_DIR"
	return 1
fi
	if [ "x$1" = x-v ];then
		local verbose=1; 
		shift
	else
		local verbose=0
	fi
	if [ "x$1" = x-p ];then
		local mkdirp=1; 
		shift
	else
		local mkdirp=0
	fi
	local exitcode=0
	while [ $# -gt 0 ]; do
		case "$1" in /*) local fname="${1%/}";; *) local fname="$PWD/${1%/}";; esac
		shift
		if [ "$(dirname "$fname")" = "$TRASH_DIR" ]; then
			local esctrashdir="$(echo "$TRASH_DIR" | sed 's/\./\\\./g; s/\//\\\//g')" # todo теоретически надо экранировать больше симолов
			local efname="$(echo "$fname" | sed -E "s/$esctrashdir"'\/[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] [0-9][0-9]-[0-9][0-9]-[0-9][0-9]//; s/%(%|-)/\/\1/g; s/\/%/%/g; s/\/-/\//g')"
			[ $verbose = 1 ] && echo "$fname --> $efname"
			if [ -d "$efname" ]; then # todo надо указать еще типы аналогичных директорий, типа сокеты, симлинки, файлы-потоки...
				echo "restore отказывается заменять существующий каталог каталогом из корзины: $efname" && exitcode=1
			else
				[ $mkdirp = 1 ] && mkdir -p "$(dirname "$efname")"
				mv -i "$fname" "$efname" || exitcode=1
			fi
		else
			local efname="$(echo "$fname" | sed -E 's/%/%%/g; s/\//%-/g')" # todo теоретически надо экранировать больше симолов
			local paths="$(find ~/.trash -name "????-??-?? ??-??-??$efname")" # todo -name надо заменить на -regexp, потому что find этот шаблон может найти в подкаталогах ~/.trash
			if [ $(echo "$paths" | wc -l) = 1 ]; then
				[ $verbose = 1 ] && echo "$paths --> $fname"
				if [ -d "$fname" ]; then # todo надо указать еще типы аналогичных директорий, типа сокеты, симлинки, файлы-потоки...
					echo "restore отказывается заменять существующий каталог каталогом из корзины: $fname" && exitcode=1
				else
					[ $mkdirp = 1 ] && mkdir -p "$(dirname "$fname")"
					mv -i "$paths" "$fname" || exitcode=1
				fi
			elif [ $(echo "$paths" | wc -l) = 0 ]; then
				echo в корзине не найдено ни одного файла "$fname"
				exitcode=1
			else
				echo в корзине найдено более одного файла "$fname" :
				echo "$paths" | sed -E 's/ /\\ /g'
				exitcode=1
			fi
		fi
	done
	return $exitcode
}
#----

# создает симлинк $1 указывающий на $2
# если файл или симлинк с таким имененм существует - переименовывает его
linkto() {
	#echo "$2" "$1"
	if [ -f "$1" -o -L "$1" ] && [ -z "$(grep -P "\\Q$2\\E\$" <(ls -l "$1") )" ]; then
		date_var="$(date "+%F-%H-%M-%S")"
		mv "$1" "$1".bak-"$date_var"
		echo "$1" moved to "$1".bak-"$date_var"
	fi
	# после переименования не должно остаться $1
	[ -f "$1" -o -L "$1" ] || ln -s "$2" "$1"
}

# добавляет строку $1 в файл $2, если там ее нет
append_line() {
	[ -z "$(grep -P "\\Q$1\\E" "$2")" ] && echo "$1" >> "$2" || return 0
}

# возвращает столбец;строку , где находится курсор
curpos() {
	# based on a script from http://invisible-island.net/xterm/xterm.faq.html
	exec < /dev/tty
	local oldstty=$(stty -g)
	stty raw -echo min 0
	# on my system, the following line can be replaced by the line below it
	echo -en "\033[6n" > /dev/tty
	# tput u7 > /dev/tty    # when TERM=xterm (and relatives)
	local pos
	read -r -d R pos
	stty $oldstty

	#echo -en "\E[6n"
	#local CURPOS
	#read -sdR CURPOS
	echo ${pos#*[}
}
